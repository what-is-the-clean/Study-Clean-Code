# [클린코드 핥아먹기 시리즈] 7. 경계


## [목차]
### 0. 개요
### 1. 외부 코드와 내부코드, 그 경계
### 2. 외부 코드의 범용성으로 인해 발생하는 문제
### 3. 외부 코드를 다룰때의 주의사항
### 4. java.util.Map
### 5. 외부 코드를 쓰기 전에 학습용 테스트를 작성해봐라
### 6. 외부 코드가 아직 개발되지 않았을 때 자체적으로 코드 대체하기
### 7. 결론


<br><br>

---

## 0. 개요


> 지난 기록에선 클린 에러를 처리하는 방법에 대한 코드 저자의 생각을 정리했다.
>
> 한 줄로 요약하자면 아래와 같이 정리할 수 있을 것 같다.


<br>

```
(1) 에러는 예외를 통해 처리하고 (2) throws에 대한 try-catch가 클라이언트 로직을 지저분하게 만든다면 DIP를 이용해 예외 상황에 쓸 클래스를 리턴시켜라.
```

<br>

어쨌든 오늘은 "경계"라는 주제에 대한 클린코드 저자의 생각을 정리하려고 한다.



<br><br>

---


## 1. 외부 코드와 내부코드, 그 경계

<br>

![image](https://github.com/choichanhyeok/---/assets/68278903/0ca7bc4c-32ac-48c0-a74c-64f5797a58e3)

<br>


> 시스템에 들어가는 소프트웨어를 한 회사에서 다 만들어 쓰기는 불가능에 가깝다. 그렇기에 필요한 역할을 할 모듈이나 패키지를 구매한다던지 오픈소스나 사내 다른 팀이 제공해주는 컴포넌트를 사용해야 하는 경우가 많다. 이로인해 우리는 소프트웨어를 내부 소프트웨어와 외부 소프트웨어로 분류하는데 이때 생겨나는 양측의 "경계"를 어떻게 하면 깔끔하게 처리할지에 대한 저자의 생각을 정리한게 이번 장의 골조이다.



<br><br>

---


## 2. 외부 코드의 범용성으로 인해 발생하는 문제


```
- 인터페이스 제공자와 인터페이스 사용자 사이에는 관점의 차이가 존재한다. 
- 인터페이스 제공자는 제공하는 패키지나 프레임워크가 더 넓은 환경에서 돌아가길 원한다. 
- 그래야 다양한 환경의 사용자를 수용할 수 있으니까. 

이런 인터페이스 제공자에게 편리한 구조는 사용자에게 불필요한 기능도 억지로 밀어넣을 수 밖에 없게된다.
```


<br>

![image](https://github.com/choichanhyeok/---/assets/68278903/7e4ba3c0-39b7-46cf-ab7c-a2b73e70569c)


> 위 그림에서 보면 맥 PC의 경우에는 범용적으로 이것저것 다 할 수 있는 사양을 가지고 있다. 이런 부분은 저 맥 PC를 판매하는 입장(인터페이스 제공자)에선 편리하다. 다양한 고객에 니즈에 맞춰 여러 모델을 관리할 필요 없이 저 모델 하나만 팔면 되기 때문이다. 반면 사용자의 입장에선 입맛에 맞게 해당 PC의 스펙을 수정하기 어렵다. 

​<br>

​

예를 들면 아래와 같다.



![image](https://github.com/choichanhyeok/---/assets/68278903/10c7b043-57e4-4a0c-8bc4-a762e5e4cd18)


> 예를 들어 내가 한 아이의 아빠라고 가정하자. 아이가 컴퓨터 게임을 안했으면 좋겠고 코딩만 했으면 좋겠는데 맥 PC는 코딩도 할 수 있고 게임도 할 수 있다. 그럼 아이가 게임을 못하게 하려면 어떻게 해야할까? 가뜩이나 예민한 아이에게 또 얼굴 붉히는 소리를 해야한다. 이처럼 인터페이스 제공자(애플) 입장에서 편한 범용적 인터페이스 판매는 클라이언트(인터페이스 사용자)에게 필요한 세부적인 요청을 들어줄 수 없다. 
<br>
​

> 반면 사용자의 환경에 커스텀화된 인터페이스는 이를 해결할 수 있는데 만약 애플에서 "게임 중독을 겪고 있는 아들을 위한 그래픽 처리능력 0% 패키지!"라는 맥 PC 시리즈를 판매한다면 해당 컴퓨터로 게임을 못하길 원하는 사용자는 그냥 해당 패키지를 사면 된다. 

<br>​

![image](https://github.com/choichanhyeok/---/assets/68278903/2d145866-ea61-4799-a3da-eaac32fbfb08)

<br>


> 다만 안타깝게도 무조건적으로 모든 외부 코드가 사용자에게 딱 맞는 인터페이스를 제공할 순 없다. 
> 
> 이에 대한 예시로 저자는 java.util.Map 인터페이스를 제시한다.

​

​<br><br>

---


## 3. 외부 코드를 다룰때의 주의사항


```
[java.util.Map의 interface]

1. clear() void - Map
2. containsKey(Object key) boolean - Map
3. containsValue(Object value) boolean - Map
4. entrySet() Set - Map
5. equals(Object o) boolean - Map
6. get(Object key) Object
.
.
```


> 위에 기재된 java.util.Map의 interface를 봤을 때 아래 2가지 문제가 발생할 수 있다.

​<br>

```
(1) Map에 특정 객체 유형만 저장하고 싶은 경우
(2) Map을 이용해 여러곳에 넘길 때, 넘기는 쪽에서는 이걸 쓰는 곳에서 Map에 대한 내용을 삭제 안할거라 생각하는 경우
1번의 경우에, productMap을 써도 결국 Map객체이기 때문에 자료형에 구애받지 않는다. Product 클래스를 개발한 개발자가 어떤 생각을 했든 이를 가져다 쓰는 Order 클래스의 개발자는 지 맘대로 productMap에 어떤 유형의 객체도 추가할 수 있게 되버린다.
```
​<br>

> 2번의 경우에, Product(상품)라는 클래스에서 넘긴 productMap이라는 객체를 Order(주문)클래스에서 받아 사용한다고 가정해보자. 이 때 Product클래스를 작성한 개발자는 주문하는 과정에서 당연히 상품정보가 담긴 productMap의 내용을 지울리 없다고 생각하고 관련 내용들을 개발했는데 Map에는 clear()메서드가 존재해 Order 클래스를 개발하는 개발자가 지 멋대로 상품 정보를 한 트랜잭션 안에서 지워버렸다고 가정하자. 이 때 해당 객체의 다른 메서드가 "productMap"에 있던 정보를 필요로 한다면 문제가 생기게 된다.


​<br><br>

---


## 4. java.util.Map

> 먼저 본 3절에서 제시한 java.util.Map가 발생시키는 1번 문제부터 해결해보려고 한다.


```
Map sensors = new HashMap();
위 코드를 보자. 위 HashMap()에는 어떤 객체도 put() 할 수 있는데 저 Map 객체를 응답받은 클라이언트는 마음대로 clear 메서드를 실행할 수 있고 내부 데이터를 조회하기도 어렵다. 아래 코드를 보자.

Sensor s = (Sensor)sensors.get(sensorId);
저 sensors라는 Map 객체에서 나오는게 요소가 모든 자료형을 커버할 수 있는 Object로 내려오기 때문에 Sensor로 형변환을 해줘야한다. 사실 이는 제네릭을 이용하면 바로 해결할 수 있는데 이는 아래와 같다.

Map<String, Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId);
```


![image](https://github.com/choichanhyeok/---/assets/68278903/fa684abf-9e5d-4234-8a57-cf790d4b5baf)

[그림4]. 헤치웠나?


<br>​

> 일단 앞서 제시한 "(1) Map에 특정 객체 유형만 저장하고 싶은 경우"에 대해선 부분적으로 해결했다. 아직도 "사용자가 Map의 제네릭 타입을 알아야하고, 만약 해당 클래스에서 Map<String, Sensor>이라는 제네릭 타입이 <Long,Sensor>등으로 바뀐다고 했을 때 극단적인 상황으로 10개의 클래스에서 사용했다고 하면 해당 클래스들을 다 돌며 수정해야한다. 또 Map 인터페이스 자체가 변경될 가능성도 있다.

##### (+심지어 제네릭스를 지원하지 않는 환경일 경우도 있다)


​<br>

> (1)번에서 추가적으로 나올 수 있는 위 문제들과 동시에 (2)번도 같이 해결할 수 있는 방법을 저자는 제시하는데 바로 "Map에 대한 관리는 클래스에서 해라"이다. 아래 코드를 보자.


```
public class Sensor {
    private Map sensors = new HashMap();

    public Sensor getById(String id){
        return (Sensor) sensors.get(id);
    }
    
    // 이하 생략
}
```

<br>

> 위 처럼 클래스를 통해 map에 접근토록 해주면 사용자는 "sensors.get(id)를 하면 Sensor이 반환되는구나!"만 알더라도 간편하게 id로 센서값을 조회하는 로직을 수행할 수 있게된다.

​<br>

![image](https://github.com/choichanhyeok/---/assets/68278903/1e05c2fc-f33c-4ce2-8012-a48f42765a1f)

<br>

> 다만 저자가 이런 설명을 했던 이유는 Map을 공개 API의 인수로 넘길 때 발생할 수 있는 문제에 대해 말한것이기 때문에 "아하! Map은 무조건 저렇게 캡슐화하고 추상화해서 쓰면 되는구나!"라고 생각하면 안된다. 

​

> ﻿핵심은 "Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출시키지 않도록 주의해라"
> 만약 Map을 여기저기 넘겨야 하는 상황에선 되도록 위 예시처럼 캡슐화해 간접적으로 노출시켜라. 
​


​<br><br>

---

## 5. 외부 코드를 쓰기 전에 학습용 테스트를 작성해봐라

> 학습 테스트는 공짜 이상이다.
> 저자는 외부 코드에 대한 학습을 위해 "테스트 코드"를 쓰기를 권고했다. 그에 대한 설명을 마칠때 즈음 "학습"이라는 장점 외에도 다른 장점이 있다며 신나서 설명하는데 테스트 코드의 보다 근본적인 장점인 "시스템 안정성"을 제시했다. 사실 외부 코드 같은 경우는 업데이트 하는 경우가 굉장히 잦다. 회사에서도 다양한 솔루션 업체들이 자신들이 제공하는 소프트웨어를 업그레이드 하러 오는 경우가 왕왕 있는데 소프트웨어 교체 이후에 문제가 있어서 긴급하게 달려와 눈 앞에서 수정하는 걸 본 적이 있다. 최근 카카오 툴킷 관련해서도 문제가 있어 해당 솔루션 업체 사람들이 방문해 해결하고 갔었는데 사실 이런 외부 코드에 대해서도 테스트 코드가 작성되어 있었다면 더 빠르게 문제를 인식할 수 있지 않았을까 싶다.


​
​<br><br>

---


## 6. 외부 코드가 아직 개발되지 않았을 때 자체적으로 코드 대체하기

> 우리는 지금 Communication controller을 개발한다고 가정하자. 우리는 개발을 위해 다른 팀에서 제공해줘야 하는 Transmitter API가 필요한데, 아직 해당 팀은 인터페이스 명세조차 안했을 때 우리는 어떻게 해야할까? 손 놓고 기다릴수도 있지만 저자는 아래 같은 해결책을 제시했다.

​
```
[Communication controller]  ->  [(interface) Transmitter]  <-   - [Fake Transmitter]
                                                                - [Transmitter Adapter]  ->  [(future) Transmitter API]
(1) CommunicationController을 분리하고
(2) 외부 팀이 담당할 Transmitter을 인터페이스로 추상화한다.
(3) 실제 Transmitter에 대한 구현체가 개발되기 전에 사용할 가짜 구현체 (Fake Transmitter)을 작성한다.
(4) 개발에 필요한 값은 Fake Transmitter을 통해 제공받아 개발을 마무리한다.
(5) 실제 TransmitterAPI 개발이 완료되면 기존의 Fake Transmitter와 API를 교체한다.

+ 단, 이 때 Adapter Pattern을 이용해 API 사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한곳으로 모으면 좋다.
```

​<br><br>

---


## 7. 결론

![image](https://github.com/choichanhyeok/---/assets/68278903/4ab789b8-b960-455f-99b1-5e4f82b43fdc)

```
[결론]
1. 자체적으로 시스템을 위한 모든 걸 개발할 수 없다. 외부 코드의 도움이 필요하다
2. 외부 코드는 범용적인 경우가 많아 우리 시스템 전반에 퍼지면 유지보수에 어려움이 생길 수 있다
3. 이런 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출시키지 않도록 주의해라
4. 만약 여기저기 넘겨야 하는 상황에선 되도록 알려준 예시처럼 캡슐화해 간접적으로 노출시켜라
5. 외부 코드는 학습을 위해서, 업그레이드시 시스템 안정성을 위해서 테스트 코드를 작성해라
6. 외부 코드 써야하는데 해당 담당자들이 아직 개발 시작도 안했다면 외부 코드 로직과 우리 코드를 먼저 분리해라
7. 그리고 외부 코드 영역을 커버할 동일한 인터페이스의 가짜 클래스를 생성해 개발하고 외부 코드 개발이 끝나면 교체해라
8. 추가로 API 변경시 수정될 코드들을 안정성과 편의성을 위해 어뎁터 패턴을 이용해 한곳으로 모아둬라.

* 외부 코드 사용은 불가피하지만 휘둘리지 않도록 경계를 잘 관리해라.
```

<br><br>

2023-07-27
개발자 최찬혁




