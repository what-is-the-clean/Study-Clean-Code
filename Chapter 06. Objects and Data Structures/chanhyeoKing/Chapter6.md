# [클린코드 핥아먹기 시리즈] 5. 객체와 자료구조

## [목차]

#### 0. 개요

#### 1. 자료를 클라이언트에게 전달할 방법을 추상화하라

#### 2. 자료와 객체의 비대칭

#### 3. 디미터 법칙

#### 4. DTO는 사이비 캡슐화이며 활성 레코드를 잡종 구조로 만들지 마라

#### 5. 결론
 
<br><br>

---
## 0. 개요


> 지난 기록에서는 클린 코드의 저자가 "주석"이라는 개념에 대해 어떻게 생각하는지에 대해 다뤘다.
> 결론은 "주석을 필요악이다"라는 걸로 이해헀고 그 다음장인 형식 맞추기는 IDE를 쓰는 요즘 굳이 볼 필요가 없을 거 같아 
> 그냥 넘기기로 했다.
>
> 이번 기록에서는 객체와 자료구조에 대한 저자의 생각을 정리해 기록하려 한다.

 <br><br> <br>

---

1. ## 자료를 클라이언트에게 전달할 방법을 추상화하라

<br>


```
# (1) 구현이 외부로 노출된 경우
class Point(var x: Double, var y: Double)

# (2) 올바른 추상화
interface Point {
    fun getX(): Double
    fun getY(): Double
    fun setCartesian(x: Double, y: Double)
    fun getR(): Double
    fun getTheta(): Double
    fun setPolar(r: Double, theta: Double)
}
```


> 클래스(1) 의 경우 생성자 주입을 해주긴 했지만 구현이 외부로 노출되 있다. 사용자는 참조를 통해 외부에서 쉽게 x, y를 사용할 수
> 있고 비공개 변수 각각에 대해 수정, 조회를 할 수 있다.


<br>

![image](https://github.com/choichanhyeok/---/assets/68278903/c2a75703-8f98-4534-87d5-17d1d3ba189f)


<br>

## 코틀린에는 자바의 final 같은 읽기 전용 변수를 만드는 val 이라는 키워드가 있다. <br>
### 이를 이용하면

```
class Point(val x: Double, val y: Double) { .. }
```

>외부에서 위 값을 조회할 수 있는데 사실 이것도 클래스의 각 요소에 직접 접근하는 것이기 때문에 괜찮은 캡슐화로 보기 어렵다.
>흔히 자바에서 getter을 따로 구현해서 작업하는 것이나 final과 생성자 주입을 이용해 값을 세팅하는것과 진배 없다는 얘기다.
>
>(2)의 올바른 추상화에서도 보면 getX()와 getY() 같은 Getter 형식의 메서드를 작성해뒀는데 사실 저자가 말하고 싶은건 클래스가 "읽기-쓰기"에 대한 정책을 가지고 있다는 점으로 이해했다.

<br>

#### 👌 get 같은 경우는 읽기 전용 변수가 있는 코틀린에서 비교하긴 어려울 거 같아 set관련 내용만 보면

```
(1) fun setCartesian(x: Double, y: Double)
(2) fun setPolar(r: Double, theta: Double)
```

<br>

> 위 코드를 봤을 때 설정 관련 정책에 "강제성"이 부여되어 있다.
> 사용자는 setCartesian()이라는 메서드 명과 입력 형식만 보고 맞춰 넣어주면 된다. 내부 동작 원리를 알 필요가 없는 것이다.
> (사실 이런 값을 setting하는 경우에는 한번 더 확인하는게 맞긴 하지만, 이론적으로 보면 맞는 말 같다.)
> 
> 결론은 Getter, Setter 같이 각각의 필드 값에 대해 무지성으로 접근 가능케 하지 말고 인터페이스(자바 인터페이스가 아니라 그냥 사용자가 사용할 수 있는 메서드)을 만들어서 사용자는 추상화된 접근 정책을 통해 클래스의 필드를 관리할 수 있게 하라는 의미이다.

​
<br>

![image](https://github.com/choichanhyeok/---/assets/68278903/c991ed7c-9979-4f7b-aca6-74e1ca3f2fea)

<br>

```
(1) idiot
public interface Vehicle {
    double getFuelTankCapacityInGallons();
    double getGallonsOfGasoline();
}
(2) Good ~
public interface Vehicle {
    double getPercentFuelRemaining();
}
```

<br> 

> 위 인터페이스를 보자. 똑같은 getter 역할을 하는 메서드지만 Vehicle을 상속받는 클래스의 어떤 필드에 어떤 접근을 할지 알 수 있는가? 없을 것이다. 그렇다 "갤론 단위의 연료탱크 용량이라는 필드"의 값을 조회하고 있다는 사실을 알 수 있다.
​

> 반면 (2)의 경우엔 "아~ 남아 있는 연료의 양을 백분율로 조회하는 거구나"라는 사실만 알 수 있을 뿐 이게 가솔린인지 겔론 단위의 용량을 계산하는건지 따위는 클라이언트 입장에서는 알 필요가 없다. 그렇기 때문에 추상화가 이루어졌다고 볼 수 있다.

​
<br>
​
```
개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다. 
아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.

- 로버트 C. 마틴
```
​
<br>


![LaughingBabiesGIF](https://github.com/choichanhyeok/---/assets/68278903/4cf01339-6ea7-4782-8410-9d0d610d0fb6)


```
[고민]
이론상 Getter을 사용하지 않는 것이 좋은 것 까진 알겠으나 (Setter를 쓸 필요가 없는 건 인정한다)
생성자 주입을 사용한다던지, Builder 같은 것들은 자주 쓰는 방법이다. 하지만 이 경우에 사용자는 본의 아니게(?) 클래스 내부의
필드값을 살펴봐야한다. 이미 Getter가 아니더라도 클래스 내부 필드를 볼 일은 많다. 팀에서 관례적으로 사용하는 형태의 메서드가 아닌
경우 메서드 이름만 보고 "오~ 이거 가솔린 양 백분율로 받는거구나!"하고 그냥 가져다 쓸 수 있는 용맹한 개발자가 과연 몇이나 될까?
또 오랜기간 사용되온 직관적인 getter()형태와 다르게 개발자에 의해 결정될 조회, 설정 정책을 담당할 메서드의 이름은 지나치게 추상적이 될 수 있다.

추상화라는건 일반화를 의미하며, 일반화 한다는 건 곧 중요한 부분을 제외한 나머지 것들을 덜어낸다는 것이다. 이 과정에서 생길 수
있는 다양한 문제들을 감수하면서 까지 현재 수많은 개발자들이 문제 없이 사용하고 있는 @Getter를 자제해야할 만큼의 필요성이 있는지
는 아직 백프로 동의하기가 어렵다. 

[고민 결과]
근데 여기서 저자가 주장하는 Getter는 단순히 자료 저장만을 목적으로 하는 "자료구조형 클래스"에 쓰지 말라는게 아니라 실제 시스템 동작을
위해 주체적인 객체로서 활동되고 있는 객체에 대해 쓰지 말라는거기 때문에 그런 객체들에 대해선 @Getter를 쓸 필요가 없어 보인다.
```




<br><br><br><br>

--- 

2. ## 자료구조와 객체의 비대칭성

```
[객체지향과 절차지향의 양분성]

"객체는 자신이 가진 자료들을 추상화  뒤로 숨기고, 자료를 다루는 메서드만 공개해야한다."
반면 자료구조는 자료를 그대로 공개하고 별 다른 함수를 제공하지 않는다. 그렇다고 무조건 바보같다고 말하긴 애매하다.
```
​
<br>

### 😒자료구조 관점로서의 클래스 Square, Rectangle, Cricle

```
# 절차적인 도형 클래스

public class Square {
    public Point topLeft;
    public double side;
}

public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
}

public class Circle {
    public Point center;
    public double radius;
}

public class Geometry {
    public final double PI = 3.141592653589793;

    public double area(Object shape) throws NoSuchShapeException {
        if (shape instanceof Square) {
            Square s = (Square) shape;
            return s.side * s.side;
        } else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle) shape;
            return r.height * r.width;
        } else if (shape instanceof Circle) {
            Circle c = (Circle) shape;
            return PI * c.radius * c.radius;
        }
        throw new NoSuchShapeException();
    }
}
```

<br>

> 위 코드에서 각 도형 클래스들은 단순한 "자료구조"의 역할밖에 수행하지 못하고 있다. 다만 위 코드는 두 가지 관점으로 볼 수 있는데

<br>
​

```
﻿(1) 클래스에 둘레 길이를 구하는 permiter()를 추가 하고 싶은경우
(2) 새 도형을 추가하고 싶은 경우
```


<br>




> #### (1)의 경우에는 사실 그냥 Geometry안에 permiter 메서드만 추가해주면 끝이다. 반면 객체지향 코드에선 모든 객체에 추가해줘야 한다. 다만 (2)의 경우에는 새로운 도형 클래스 생성후 Geometry에 속한 함수들을 모두 고쳐야한다. 

<br>

#### 😊다형적인 도형 클래스를 이용한 방법


```
public class Square implements Shape {
    private Point topLeft;
    private double side;

    public double area() {
        return side * side;
    }
}

public class Rectangle implements Shape {
    private Point topLeft;
    private double height;
    private double width;

    public double area() {
        return height * width;
    }
}
```


> 만약 (1)의 문제를 해결하기 위해선 절차지향적 방법과 다르게 모든 도형 클래스에 들어가 각각의 다형 메서드들을 손봐야겠지만 (2)의 경우에는 그냥 새 도형을 추가해주면 그걸로 끝이다. 차이를 알겠는가?

<br>

```
1. 자료구조적 형태의 클래스를 이용해 코딩하면 "다형 메서드"등을 생성할 때 이득이 있고
2. 객체지향적 형태의 도형 클래스를 이용하면 "다형성의 주체가 되는 새로운 클래스들을 생성"할 때 이득이 있다.
이걸 저자의 말로 표현하면 
```
​
<br>

> [절차지향 코드의 장점]
> > (1-1) 자료구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
> > 
> > (1-2) 절차적인 코드는 새로운 자료구조를 추가하기 어렵다.
>
> [객체지향 코드의 장점]
> > (2-1) 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
> > 
> > (2-2) 객체지향 코드는 새로운 함수를 추가하기 어렵다.

<br>

결국 근복적으로 양분된다는 내용이고 어느 한쪽이 무조건 옳다는 개념이 아님을 저자는 주장하고 있다.

<br>

​

```
"분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다."
```
​


<br><br><br><br>


---


3. ## 디미터 법칙

> 디미터 법칙은 잘 알려진 휴리스틱이다.

<br>


![image](https://github.com/choichanhyeok/---/assets/68278903/1d248fab-543f-40db-953d-6e4f47b94df3)


<br>

> 디미터 법칙이 뭘까? 아래 코드를 보자


```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

<br>

> 위 코드는 "디미터 법칙을 위배"한다고 주장하고있다. 어째서 그러냐면 디미터 법칙은 아래 규칙을 지켜야 하기 때문이다.
​

```
* 클래스 C의 메서드 f는 아래와 같은 객체의 메서드만 호출해야 한다.

(1) 클래스 C: 메서드 f는 자신을 가진 클래스 C객체의 메서드를 호출할 수 있다.
(2) f가 생성한 객체: 메서드 f는 자신이 생성한 객체의 메서드를 호출할 수 있다.
(3) f 인수로 넘어온 객체: 메서드 f는 자신에게 넘어온 객체의 메서드를 호출할 수 있다.
(4) C 인스턴스 변수에 저장된 객체: 메서드 f는 자신이 속한 C 클래스에 저장된 객체의 메서드를 호출할 수 있다.

위 조건을 기반으로 분석해보면 먼저 ctxt라는 객체가 존재하는데 getOptions().getScratchDir().getAbsolutePath()라는 연쇄적인 메서드를 통해 계속해서 얻은 객체의 메서드들을 호출해 객체의 디미터의 규칙을 어겼는지 알 수가 없게 된다. 사실 최종적으로 getAbsolutePath()를 가지고 있는 객체가 클래스 C에서 가지고 있는 객체와 동일한 경우가 있을 수 있는데 일단은 그렇게 해당 객체와 클래스 C에서 저장하고 있는 객체는 엄연히 다른 객체이기에 배제하고 봐야할 것 같다.

```

​


> #### 저자의 추상적인 표현을 빌려 결론을 짓자면 getAbsolutePath()는 직접적인 이웃 객체의 메서드가 아니기 때문에 디미터 법칙을 위배한다는 주장이다. 이렇게 길~게 늘여뜨린 구조를 기차들 갔다고 하여 "기차 충돌"이라고 하며 일반적으로 아래와 같이 개선하는게 좋다고 한다.

​


```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

>  사실 위 예제도 디미터 법칙을 위반한다고 볼 수도 있는데 ctxt, Options, ScratchDir이 객체지향적 클래스인지 단순 자료구조 성격의 클래스인지에 따라 위반하지 않는다고 볼 수 있다. 왜냐면 "자료구조 성격의 클래스 객체"에 대해선 디미터 법칙을 적용치 않기 때문이다. 만약 아래처럼


​
```
final String outputDir = ctxt.options.scratchDir.absolutePath;
```


>  위와 같이 자료에 대한 단숨 참조만 제공하는 "자료 구조" 형태의 클래스였다면 애초에 디미터 법칙을 고민할 필요가 없었다. 하지만 일반 자료구조형 클래스에 대해서도 Getter, Setter를 요구하는 프레임워크와 표준(ex. Bean)으로 인해 getter, setter 형태가 있더라도 해당 클래스가 객체형 클래스인지 단순 자료구조형 클래스인지 분간할 수 없기 때문에 디미터 법칙을 위반했다, 위반하지 않았다는 걸 예단할 수 없다.

​

​<br><br><br><br>


--- 



4. ## DTO는 사이비 캡슐화, 활성 레코드를 잡종 구조로 만들지 마라

> 사실 DTO를 처음 볼 때부터 느겼던게 있는데 "setter는 생성자 주입으로 해결한다고 치고, 아니 어차피 getter로 필드 값 1:1로 조회하는 건 매한가진데 이게 뭔 캡슐화라는거야? getter 막아 놓을 것만 private으로 설정 해놓는거랑 차이가 없잖아"라는 생각이었는데 저자는 DTO, 그 중에서 대학때 교육받은 Bean 구조의 경우에 대해 "싸이비 캡슐화"라는 표현으로 내 궁금증에 대해 대답해주었다.

​![image](https://github.com/choichanhyeok/---/assets/68278903/147ce225-69b4-471d-8e5a-3dbf86cdb931)


> 또 활성 레코드라는 DTO의 형태를 소개했는데, 이런 형태의 경우엔 절대 객체로 보지 말고 "데이터 구조"로 보고 사용하라는 조언을 했다. 왜냐면 앞서 설명한 것 처럼 "데이터 구조"와 "객체"는 양분되는 개념인데 이것들이 섞여버리면 저자의 표현으로 "잡종 구조"가 되며 양 쪽의 단점을 다 흡수해버리게 된다고 한다. 따라서 DTO가 됐든, 활성 레코드가 됐든 객체가 아닌 "자료 구조"로 바라보고 비즈니스 로직을 운용하는 주체로 쓰면 안된다는 결론을 얻었다.

​
<br>


```
[DTO 클래스의 Of 메서드]

나는 종종 DTO 클래스를 쓸 때 엔티티 객체 (활성 레코드: JPA의 경우 활성 레코드를 따르진 않지만 어쨌든)에 대한 매핑을 할 때
DTO 객체가 자체적으로 가지고 있는 of()라는 메서드를 통해 데이터를 매핑하곤 한다. 이 부분에 대해서 조금 고민을 해봤는데
결론은 of()라는 메서드는 단순히 데이터를 관리하기 위한 메서드이고 "숨겨야할 대상" 자체가 DTO 이기 때문에 DTO를 사용하는 클래스
가 있다면 거기서 추상화를 해주면 될 것 같다는 결론을 얻었다.
```

<br><br><br><br>

---

5. ## 결론

```
(1) 객체는 동작을 공개하고 자료를 숨겨야한다. (field를 숨기고 메서드를 통해 클라이언트가 조작가능토록 해라)
(2) 객체형태의 클래스는 새 클래스를 추가하긴 쉽지만 공통으로 사용하는 메서드는 추가, 수정하기 어렵다.
(3) 단순 데이터를 다루기 위한 클래스를 "자료 구조"라고 표현했는데 이는 객체 형태의 클래스와 양분되는 개념이다.
(4) 이런 자료 구조는 그냥 자료구조로만 쓰고 객체로 바라보지 마라.
(5) 자료구조를 살아있는 객체로 보면 "자료구조"와 "객체"의 단점을 다 가지고 있는 "잡종 구조"가 된다.
(6) 모든 것이 객체라는 걸 믿고 있으면 너는 "분별력 없는 개발자"이니 각각의 특징을 잘 이해하고 혼용해 써라.
```

<br><br>
#### 2023-08-14 개발자 최찬혁

